@page "/graph"
@rendermode InteractiveServer
@inject ILogger<Graph> Logger
@using Syncfusion.Blazor.Charts

<PageTitle>Graph</PageTitle>

<h3>Graph</h3>
<button class="btn btn-primary" @onclick="Clear">clear</button>
<button class="btn btn-primary" @onclick="AddModel">add model</button>
<br>
<SfChart>
    <ChartPrimaryXAxis ValueType="Syncfusion.Blazor.Charts.ValueType.DateTime" Format="dd MMM" />
    <ChartSeriesCollection>
        @foreach (Simulator model in Models)
        {
            <ChartSeries DataSource="@model.Simulate()" PointColorMapping="blue" XName="Date" YName="Wealth"
                Type="ChartSeriesType.Line" />
        }
    </ChartSeriesCollection>
</SfChart>

<label>Model count: @Models.Count</label> <br>

@for (int i = 0; i < Models.Count; i++)
{
    <button type="button">Model @(i + 1)</button>
    <br>
    <!-- TODO: make expandable overview of the model, delete just one model -->
}

<input type="checkbox" @bind="Checked" @onclick="TogglePersonCheckBox">
<label> A Real Person:</label><br>
@if (Simulant.Victim != null) {
    @Simulant.Victim.Render()
}


@code {
    /// List of used models
    List<Simulator> Models = [];
    /// the work in progress simulator
    Simulator Simulant = new();

    private bool Checked = false;
    private void TogglePersonCheckBox() {
        if (Checked) {
            Simulant.Victim = null;
        } else {
            Simulant.Victim = new();
        }
    }
    private void Clear()
    {
        Models = [];
    }
    private void AddModel()
    {
        Checked=false;
        Models.Add(Simulant);
        Simulant = new();
    }


    private class ChartData
    {
        public ChartData(DateTime date, double wealth)
        {
            Date = date;
            Wealth = wealth;
        }
        public DateTime Date { get; set; }
        public double Wealth { get; set; }
    }

    /// Represents something that generates income
    ///
    /// Assets can own other assets but their balances are seperate
    private class Asset
    {
        /// represents the ammount of money invested in this asset
        public double Balance;
        /// assets managed by this asset
        public List<Asset> Assets = new();
        /// Advances the balance of the assets and own profit by a month
        public void AdvanceByMonth()
        {
            foreach (Asset asset in Assets)
            {
                asset.AdvanceByMonth();
            }
            AddOwnMontlyProfit();
        }

        /// Pure profit excluding assets
        public virtual void AddOwnMontlyProfit()
        {
            // default balance stays the same
        }

        /// Moves `ammount` of money into `destination`
        /// usefull for monthly expenditures like moving money into a savings account
        /// Exceptions:
        /// raises an OutOfBound exception if balance is too low
        public void Move(double ammount, Asset destination)
        {
            if (Balance < ammount)
            {
                throw new System.ArgumentOutOfRangeException(
                $"Balance : {Balance} is less than requested move ammount {ammount}"
                );
            }
            Balance -= ammount;
            destination.Balance += ammount;
        }

        /// calculates the recursive ballance of all owned assets + self
        public double TotalBalance
        {
            get
            {
                double _runningTotal = Balance;
                foreach (Asset asset in Assets)
                {
                    _runningTotal += asset.TotalBalance;
                }
                return _runningTotal;
            }
        }

        /// returns the rendering of itself in html
        public RenderFragment Render(string _indent = "") {
            RenderFragment _runningTotal = RenderSelf(_indent);

            foreach (Asset child in Assets) {
                _runningTotal += child.Render($"{_indent} ");
            }

            if (_indent == "") {
                
            }

            return _runningTotal;
        }

        /// renders only its own stuff, no children
        public virtual RenderFragment RenderSelf(string _indent) {
            return @<h4>@(_indent)Asset</h4>;
        }

    }

    private class SavingsAccount : Asset
    {
        /// The Yearly Interest Rate In %
        private double InterestRate = 5;
        private double GetMonthlyInterestRate()
        {
            return Math.Pow(1 + InterestRate, 1.0 / 12.0) - 1;
        }

        public override void AddOwnMontlyProfit()
        {
            Balance *= (1 + GetMonthlyInterestRate());
        }
    }

    private class AWorkingPerson : Asset
    {
        public double StartingCapital = 0;
        public double MontlhyIncome = 10_000;
        public double WealthCap = 10_000_000;

        public override void AddOwnMontlyProfit()
        {
            Balance += MontlhyIncome;
        }
        public override RenderFragment RenderSelf(string _indent) {
            RenderFragment _runningTotal = (__builder) => {
                <h4>@(_indent)A Working Person</h4>
                <label>Montlhy Income:</label> <input @bind="MontlhyIncome" /> <br>
                <label>Starting Capital:</label> <input @bind="StartingCapital" /> <br>
                <label>Wealth Cap:</label> <input @bind="WealthCap" /> <br>
            };
            return _runningTotal;
        }

    }
    private class Simulator
    {
        public AWorkingPerson? Victim;
        public double WealthGoal = 1_000_000;
        public List<ChartData> Simulate()
        {
            List<ChartData> data = new();
            DateTime today = DateTime.Today;

            if (Victim == null) {
                return data;
            }
            Victim.Balance = Victim.StartingCapital;

            for (int i = 0; i < 12 * 30; i++)
            {
                Victim.AdvanceByMonth();
                data.Add(
                new ChartData(today.AddMonths(i), Victim.TotalBalance)
                );
            }

            return data;
        }
    }
}
